	.file	"Blink.cpp"
	! ABI version
	.abi_2
	! This asm file is generated by compiler
	.flag	verbatim
	! This vector size directive is required for checking inconsistency on interrupt handler
	.vec_size	16
	! ------------------------------------
	! ISA family		: V3M
	! Pipeline model	: N8
	! Code model		: LARGE
	! Endian setting	: little-endian
	! Use SP floating-point instruction	: No
	! Use DP floating-point instruction	: No
	! ABI version		: ABI2
	! ------------------------------------
	! Use conditional move		: Yes
	! Use performance extension	: No
	! Use performance extension 2	: No
	! Use string extension		: No
	! ------------------------------------
	! V3PUSH instructions	: No
	! 16-bit instructions	: No
	! Reduced registers set	: Yes
	! ------------------------------------
	! Optimization level	: -O0
	! ------------------------------------
	! Cache block size	: 16
	! ------------------------------------
	.text
	.align	1
	.global	_Z5setupv
	.type	_Z5setupv, @function
_Z5setupv:
	! BEGIN PROLOGUE
	!     fp needed: 0
	!  pretend_args: 0
	!    local_size: 0
	! out_args_size: 0
	! registers ever_live: $r0, $r1, $ta, $lp, $sp, 
	! function attributes: None
	push.s	{ $lp }
	addi	$sp, $sp, -4
	! END PROLOGUE
	movi	$r0, 13
	movi	$r1, 1
	bal	pinMode
	! BEGIN EPILOGUE
	addi	$sp, $sp, 4
	pop.s	{ $lp }
	ret
	! END EPILOGUE
	.size	_Z5setupv, .-_Z5setupv
	.align	1
	.global	_Z4loopv
	.type	_Z4loopv, @function
_Z4loopv:
	! BEGIN PROLOGUE
	!     fp needed: 0
	!  pretend_args: 0
	!    local_size: 8
	! out_args_size: 0
	! registers ever_live: $r0, $r1, $ta, $lp, $sp, 
	! function attributes: None
	push.s	{ $lp }
	addi	$sp, $sp, -24
	! END PROLOGUE
# ---- Program start
swi	$fp,	[$sp]
addi	$sp,	$sp,	-4
addi	$fp,	$sp,	0
# ---- Installing symbol: a on $fp+(0)
addi	$sp,	$sp,	-4
movi	$r0,	1
swi	$r0,	[$sp]
addi	$sp,	$sp,	-4
# ---- Assigning symbol: "a" to the content of stack top
lwi	$r0,	[$sp+4]
swi	$r0,	[$fp+(0)]
# ---- stack poping
addi	$sp,	$sp,	4
# ---- While starts
L0:
lwi	$r0,	[$fp+(0)]
swi	$r0,	[$sp]
addi $sp, $sp, -4
movi	$r0,	5
swi	$r0,	[$sp]
addi	$sp,	$sp,	-4
lwi	$r0,	[$sp+8]
lwi	$r1,	[$sp+4]
# ----  compare if $r0 < $r1
slts $r0, $r0, $r1
# ---- Store the compared result in [$sp+8]
swi	$r0,	[$sp+8]
# ---- stack poping
addi	$sp,	$sp,	4
# ---- break out while loop if expr is true
lwi	$r0,	[$sp+4]
# ---- stack poping
addi	$sp,	$sp,	4
beqz	$r0,	L1
# ---- Installing symbol: b on $fp+(-4)
addi	$sp,	$sp,	-4
movi	$r0,	0
swi	$r0,	[$sp]
addi	$sp,	$sp,	-4
# ---- Assigning symbol: "b" to the content of stack top
lwi	$r0,	[$sp+4]
swi	$r0,	[$fp+(-4)]
# ---- stack poping
addi	$sp,	$sp,	4
lwi	$r0,	[$fp+(0)]
swi	$r0,	[$sp]
addi $sp, $sp, -4
movi	$r0,	1000
swi	$r0,	[$sp]
addi	$sp,	$sp,	-4
# ----  '*' top two word on stack([$sp+8] * [$sp+4]) and store at [$sp+8]
lwi	$r0,	[$sp+8]
lwi	$r1,	[$sp+4]
mul	$r0,	$r0,	$r1
swi	$r0,	[$sp+8]
# ---- stack poping
addi	$sp,	$sp,	4
# ---- Assigning symbol: "b" to the content of stack top
lwi	$r0,	[$sp+4]
swi	$r0,	[$fp+(-4)]
# ---- stack poping
addi	$sp,	$sp,	4
# ---- DigitalWrite HIGH
movi	$r0,	13
movi	$r1,	1
bal	digitalWrite
# ---- Delay b
lwi	$r0,	[$fp+(-4)]
bal	delay
# ---- DigitalWrite LOW
movi	$r0,	13
movi	$r1,	0
bal	digitalWrite
# ---- Delay b
lwi	$r0,	[$fp+(-4)]
bal	delay
lwi	$r0,	[$fp+(0)]
swi	$r0,	[$sp]
addi $sp, $sp, -4
movi	$r0,	1
swi	$r0,	[$sp]
addi	$sp,	$sp,	-4
# ----  '+' top two word on stack([$sp+8] + [$sp+4]) and store at [$sp+8]
lwi	$r0,	[$sp+8]
lwi	$r1,	[$sp+4]
add	$r0,	$r0,	$r1
swi	$r0,	[$sp+8]
# ---- stack poping
addi	$sp,	$sp,	4
# ---- Assigning symbol: "a" to the content of stack top
lwi	$r0,	[$sp+4]
swi	$r0,	[$fp+(0)]
# ---- stack poping
addi	$sp,	$sp,	4
j L0
L1:
# ---- While ends
movi	$r0,	0
swi	$r0,	[$sp]
addi	$sp,	$sp,	-4
# ---- Program stop
addi	$sp,	$fp,	4
lwi	$fp,	[$sp]
	! BEGIN EPILOGUE
	addi	$sp, $sp, 24
	pop.s	{ $lp }
	ret
	! END EPILOGUE
	.size	_Z4loopv, .-_Z4loopv
	.ident	"GCC: (2015-08-24_nds32le-elf-mculib-v3m) 4.9.2"
	! ------------------------------------